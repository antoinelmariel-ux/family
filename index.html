<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Éditeur de Procédures IA Friendly</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      color-scheme: light;
      --primary: #2f4f9f;
      --accent: #f8f9ff;
      --border: #dce0f3;
      --text: #1c2240;
      --muted: #5c6280;
      --warning: #d64545;
      --success: #20895e;
      --bg: #f4f6fb;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    header {
      background: white;
      padding: 24px 32px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 16px;
    }

    header h1 {
      margin: 0;
      font-size: 24px;
    }

    .header-brand {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .header-logo {
      height: 48px;
      width: auto;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .new-procedure-btn {
      padding: 10px 18px;
      border-radius: 10px;
      border: none;
      background: var(--primary);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(47, 79, 159, 0.2);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .new-procedure-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(47, 79, 159, 0.25);
    }

    .info-card {
      background: var(--accent);
      border: 1px dashed var(--primary);
      color: var(--text);
    }

    .info-card p {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
    }

    .info-card ul {
      margin: 12px 0 0;
      padding-left: 20px;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.5;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 340px;
      gap: 24px;
      padding: 24px 32px 64px;
    }

    .card {
      background: white;
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 8px 24px rgba(28, 34, 64, 0.08);
      border: 1px solid var(--border);
    }

    .card h2 {
      margin-top: 0;
      font-size: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .card h3 {
      margin-top: 24px;
      font-size: 18px;
    }

    label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
    }

    input[type="text"],
    textarea,
    select,
    input[type="date"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #fff;
      font-size: 14px;
      font-family: inherit;
      transition: border 0.2s, box-shadow 0.2s;
    }

    textarea {
      min-height: 80px;
      resize: vertical;
    }

    input:focus,
    textarea:focus,
    select:focus,
    .editor:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(47, 79, 159, 0.15);
    }

    .metadata-grid {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .metadata-group {
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      background: #f9faff;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: inset 0 0 0 1px rgba(47, 79, 159, 0.05);
    }

    .metadata-group-header h3 {
      margin: 0;
      font-size: 17px;
    }

    .metadata-group-header p {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.45;
    }

    .metadata-group-fields {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px 20px;
    }

    .field-hint {
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
    }

    .keyword-input-wrapper {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .keyword-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .keyword-tag {
      display: inline-flex;
      align-items: center;
      padding: 6px 10px 6px 12px;
      border-radius: 999px;
      font-size: 13px;
      font-weight: 600;
      border: 1px solid transparent;
      background: var(--accent);
      color: var(--primary);
      gap: 8px;
    }

    .keyword-remove {
      appearance: none;
      border: none;
      background: transparent;
      color: inherit;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
      padding: 0;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .keyword-remove:focus {
      outline: none;
      text-decoration: underline;
    }

    .keyword-empty {
      font-size: 13px;
      color: var(--muted);
    }

    .backoffice-card {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .backoffice-description {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.5;
    }

    .backoffice-section {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 18px;
      background: #f7f8ff;
      display: flex;
      flex-direction: column;
      gap: 14px;
      box-shadow: inset 0 0 0 1px rgba(47, 79, 159, 0.08);
    }

    .backoffice-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .backoffice-section-header h3 {
      margin: 0;
      font-size: 16px;
    }

    .backoffice-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .backoffice-controls input[type="text"] {
      flex: 1 1 240px;
      min-width: 200px;
    }

    .backoffice-add-btn {
      padding: 8px 14px;
      border-radius: 8px;
      border: none;
      background: var(--primary);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      font-size: 13px;
      box-shadow: 0 2px 6px rgba(47, 79, 159, 0.25);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .backoffice-add-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(47, 79, 159, 0.25);
    }

    .backoffice-reset-btn {
      padding: 8px 14px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      font-weight: 600;
      cursor: pointer;
      font-size: 13px;
    }

    .option-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .option-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: var(--accent);
      color: var(--primary);
      border: 1px solid rgba(47, 79, 159, 0.25);
      font-size: 13px;
      font-weight: 600;
    }

    .option-pill-remove {
      appearance: none;
      border: none;
      background: none;
      color: var(--warning);
      font-weight: 700;
      cursor: pointer;
      padding: 0;
      line-height: 1;
      font-size: 14px;
    }

    .option-pill-remove:focus {
      outline: none;
      text-decoration: underline;
    }

    .option-empty {
      font-size: 13px;
      color: var(--muted);
    }

    .editor-card {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .toolbar button {
      padding: 8px 12px;
      border: 1px solid var(--border);
      background: var(--accent);
      color: var(--text);
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      transition: transform 0.15s, box-shadow 0.15s;
    }

    .toolbar button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(28, 34, 64, 0.12);
    }

    .rational-block {
      border: 1px dashed var(--primary);
      background: rgba(47, 79, 159, 0.08);
      border-radius: 12px;
      padding: 16px 18px;
      margin: 20px 0;
    }

    .rational-block-title {
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-size: 12px;
      margin: 0 0 12px;
      color: var(--primary);
    }

    .rational-block[data-block-type="rationnel"] p {
      margin: 0;
    }

    .editor {
      min-height: 320px;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px 20px;
      line-height: 1.6;
      font-size: 15px;
      background: #fff;
      overflow-y: auto;
    }

    .editor h1,
    .editor h2,
    .editor h3,
    .editor h4 {
      font-weight: 700;
      margin-top: 24px;
    }

    .editor ul,
    .editor ol {
      padding-left: 24px;
    }

    .qa-item {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      background: #fafbff;
    }

    .qa-actions {
      display: flex;
      justify-content: flex-end;
    }

    .remove-btn {
      background: none;
      border: none;
      color: var(--warning);
      font-weight: 600;
      cursor: pointer;
    }

    .insights {
      display: flex;
      flex-direction: column;
      gap: 16px;
      position: sticky;
      top: 120px;
      max-height: calc(100vh - 140px);
      overflow-y: auto;
    }

    .insight-card {
      border-left: 4px solid var(--primary);
      padding: 16px;
      border-radius: 12px;
      background: #fff;
      box-shadow: inset 0 0 0 1px var(--border);
    }

    .insight-card h3 {
      margin: 0 0 8px;
      font-size: 16px;
    }

    .insight-list {
      margin: 0;
      padding-left: 18px;
      color: var(--muted);
      font-size: 14px;
    }

    .guideline-comment-list {
      list-style: none;
      padding-left: 0;
    }

    .guideline-comment-list li + li {
      margin-top: 12px;
    }

    .insight-comment {
      display: flex;
      gap: 12px;
      align-items: flex-start;
    }

    .comment-anchor {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px 8px;
      border-radius: 999px;
      background: var(--accent);
      color: var(--primary);
      font-weight: 600;
      font-size: 12px;
      border: 1px solid rgba(47, 79, 159, 0.2);
      white-space: nowrap;
    }

    .comment-message {
      flex: 1;
      font-size: 13px;
      line-height: 1.5;
      color: var(--text);
    }

    .export-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 24px;
    }

    .primary-btn,
    .secondary-btn {
      padding: 12px 18px;
      font-size: 15px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      border: none;
    }

    .primary-btn {
      background: var(--primary);
      color: white;
    }

    .primary-btn:disabled {
      background: #b0b7d6;
      cursor: not-allowed;
    }

    .secondary-btn {
      background: white;
      color: var(--primary);
      border: 1px solid var(--primary);
    }

    .warning {
      color: var(--warning);
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }

    .preview-modal {
      position: fixed;
      inset: 0;
      background: rgba(10, 14, 35, 0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 32px;
      z-index: 10;
    }

    .preview-content {
      background: white;
      border-radius: 16px;
      max-width: 960px;
      width: 100%;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 12px 36px rgba(14, 24, 56, 0.32);
    }

    .preview-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .preview-body {
      padding: 24px;
      overflow-y: auto;
      background: #f9f9ff;
    }

    pre {
      background: #fff;
      border-radius: 12px;
      padding: 20px;
      overflow-x: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 13px;
    }

    footer {
      background: white;
      border-top: 1px solid var(--border);
      padding: 16px 32px;
      text-align: right;
      font-size: 13px;
      color: var(--muted);
    }

    @media (max-width: 1100px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .insights {
        position: static;
        max-height: none;
      }
    }

    @media (max-width: 600px) {
      header {
        padding: 20px;
        justify-content: flex-start;
      }

      .header-brand {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }

      .header-logo {
        height: 40px;
      }

      .header-actions {
        width: 100%;
        justify-content: flex-start;
      }

      .new-procedure-btn {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <footer>
    Version 1.1.14
  </footer>

  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/turndown@7.1.2/dist/turndown.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script type="text/babel">
    const { useState, useMemo, useRef, useEffect } = React;

    const LFB_LOGO_URL = 'https://mma.prnewswire.com/media/1736228/LFB_Logo.jpg?p=publish';

    const KEYWORD_COLOR_PALETTE = [
      { background: 'rgba(47, 79, 159, 0.15)', color: '#2f4f9f', border: 'rgba(47, 79, 159, 0.35)' },
      { background: 'rgba(32, 137, 94, 0.15)', color: '#20895e', border: 'rgba(32, 137, 94, 0.35)' },
      { background: 'rgba(214, 69, 69, 0.15)', color: '#d64545', border: 'rgba(214, 69, 69, 0.35)' },
      { background: 'rgba(237, 180, 52, 0.18)', color: '#8a5a00', border: 'rgba(237, 180, 52, 0.4)' },
      { background: 'rgba(103, 64, 152, 0.15)', color: '#5d3a92', border: 'rgba(103, 64, 152, 0.35)' }
    ];

    const metadataGroups = [
      {
        key: 'identification',
        title: 'Identification',
        description: 'Renseignez les éléments essentiels pour retrouver et suivre cette procédure.',
        fields: [
          {
            key: 'title',
            label: 'Titre',
            type: 'text',
            placeholder: 'Titre de la procédure',
            hint: 'Nom tel qu’il apparaîtra dans les exports et la base documentaire.'
          },
          {
            key: 'reference',
            label: 'Référence',
            type: 'text',
            placeholder: 'Référence interne',
            hint: 'Identifiant unique ou code interne facilitant le suivi des versions.'
          },
          {
            key: 'author',
            label: 'Auteur',
            type: 'text',
            placeholder: 'Nom complet',
            hint: 'Indiquez la personne responsable de la rédaction ou de la validation.'
          },
          {
            key: 'effectiveDate',
            label: "Date d'entrée en vigueur",
            type: 'date',
            hint: 'Date à laquelle la procédure devient applicable.'
          }
        ]
      },
      {
        key: 'contexte',
        title: 'Contexte',
        description: 'Situez la procédure au sein de votre dispositif documentaire.',
        fields: [
          {
            key: 'summary',
            label: 'Résumé',
            type: 'textarea',
            placeholder: 'Résumé exécutif de la procédure',
            hint: 'Présentez l’objectif et les points clés en quelques phrases.'
          },
          {
            key: 'parentProcedure',
            label: 'Procédure mère',
            type: 'text',
            placeholder: 'Référence ou titre',
            hint: 'Mentionnez la procédure qui encadre ou complète celle-ci, si applicable.'
          },
          {
            key: 'changeHistory',
            label: 'Historique des modifications',
            type: 'textarea',
            placeholder: 'Consignez les évolutions majeures et leurs dates',
            hint: 'Décrivez les principales modifications apportées et leur contexte.'
          }
        ]
      },
      {
        key: 'diffusion',
        title: 'Diffusion',
        description: 'Précisez à qui s’adresse la procédure et dans quelles zones elle s’applique.',
        fields: [
          {
            key: 'businessScope',
            label: 'Périmètre métier',
            type: 'select',
            options: ['Médical', 'Commercial', 'Neutre'],
            hint: 'Sélectionnez le domaine métier principalement concerné.'
          },
          {
            key: 'companyScope',
            label: 'Périmètre société',
            type: 'select',
            options: ['LFB Bio Médicament', 'LFB Biomanufacturing'],
            hint: 'Choisissez l’entité juridique ou la filiale de diffusion.'
          },
          {
            key: 'geoScope',
            label: 'Périmètre géographique',
            type: 'select',
            options: ['Monde', 'France', 'Europe hors France', 'USA', 'Mexique'],
            hint: 'Zone géographique de validité de la procédure.'
          },
          {
            key: 'keywords',
            label: 'Mots clefs',
            type: 'text',
            placeholder: 'Appuyez sur Entrée pour ajouter un mot clef',
            hint: 'Utilisez la touche Entrée pour valider chaque mot clef.'
          }
        ]
      }
    ];

    const metadataFields = metadataGroups.flatMap((group) => group.fields);

    const initialMetadata = metadataFields.reduce((acc, field) => {
      acc[field.key] = '';
      return acc;
    }, {});

    const selectFieldDefinitions = metadataFields.filter((field) => field.type === 'select');
    const SELECT_FIELD_KEYS = selectFieldDefinitions.map((field) => field.key);
    const DEFAULT_SELECT_OPTIONS = selectFieldDefinitions.reduce((acc, field) => {
      acc[field.key] = field.options ? [...field.options] : [];
      return acc;
    }, {});
    const SELECT_OPTION_STORAGE_KEY = 'procedureBuilderSelectOptions';

    function normalizeSelectOptions(options) {
      const normalized = {};
      SELECT_FIELD_KEYS.forEach((key) => {
        const defaults = DEFAULT_SELECT_OPTIONS[key] || [];
        const rawValues = options && Array.isArray(options[key]) ? options[key] : defaults;
        const sanitized = rawValues
          .map((value) => (typeof value === 'string' ? value : String(value)))
          .map((value) => value.trim())
          .filter((value) => value.length > 0);

        const unique = [];
        sanitized.forEach((value) => {
          if (!unique.some((existing) => existing.toLowerCase() === value.toLowerCase())) {
            unique.push(value);
          }
        });

        normalized[key] = unique.length > 0 ? unique : [...defaults];
      });
      return normalized;
    }

    function loadInitialSelectOptions() {
      if (typeof window === 'undefined' || !window.localStorage) {
        return normalizeSelectOptions(DEFAULT_SELECT_OPTIONS);
      }

      try {
        const raw = window.localStorage.getItem(SELECT_OPTION_STORAGE_KEY);
        if (!raw) {
          return normalizeSelectOptions(DEFAULT_SELECT_OPTIONS);
        }

        const parsed = JSON.parse(raw);
        return normalizeSelectOptions(parsed);
      } catch (error) {
        console.warn('Impossible de charger les options personnalisées :', error);
        return normalizeSelectOptions(DEFAULT_SELECT_OPTIONS);
      }
    }

    function createEmptyOptionDrafts() {
      return SELECT_FIELD_KEYS.reduce((acc, key) => {
        acc[key] = '';
        return acc;
      }, {});
    }

    const createInitialQAItems = () => [{ question: '', answer: '' }];

    const pronouns = ['il', 'elle', 'ils', 'elles', 'lui', 'leur', 'leurs', 'son', 'sa', 'ses', 'eux'];

    function formatSelection(command, value = null) {
      document.execCommand(command, false, value);
    }

    function sanitizeHTML(html) {
      return html.replace(/\s+style="[^"]*"/g, '');
    }

    const PROCEDURE_TEMPLATE = `
<h2>Objectif</h2>
<p>Précisez ici la finalité de la procédure et le résultat attendu.</p>

<h2>Champ d'application</h2>
<p>Décrivez le périmètre couvert : services, équipes, situations concernées.</p>

<h2>Pré-requis</h2>
<ul>
  <li>Listez les conditions nécessaires (documents, accès, matériels, compétences).</li>
  <li>Ajoutez toute information préalable indispensable.</li>
</ul>

<h2>Rôles et responsabilités</h2>
<ul>
  <li><strong>Acteur principal :</strong> Décrivez son rôle clé.</li>
  <li><strong>Contributeurs :</strong> Mentionnez les soutiens et leurs actions.</li>
  <li><strong>Référent :</strong> Indiquez la personne à contacter en cas de question.</li>
</ul>

<h2>Étapes détaillées</h2>
<ol>
  <li><strong>Étape 1 :</strong> Décrivez précisément la première action à mener.</li>
  <li><strong>Étape 2 :</strong> Indiquez la suite logique en précisant les points de contrôle.</li>
  <li><strong>Étape 3 :</strong> Complétez avec les actions restantes jusqu'à la finalisation.</li>
</ol>

<h2>Points de contrôle &amp; indicateurs</h2>
<p>Précisez les vérifications à réaliser et la manière d'évaluer la conformité.</p>

<h2>Gestion des écarts</h2>
<p>Décrivez la marche à suivre en cas de non-conformité ou de situation imprévue.</p>

<h2>Annexes &amp; documents associés</h2>
<p>Référencez les formulaires, modèles ou ressources complémentaires.</p>
`;

    const INITIAL_CONTENT_HTML = sanitizeHTML(PROCEDURE_TEMPLATE);

    function computeGuidelines(html, acronymDB = {}) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<div>${html}</div>`, 'text/html');
      const guidelines = [];

      doc.querySelectorAll('h1, h2, h3, h4').forEach((heading) => {
        const text = heading.textContent.trim() || '(titre sans texte)';
        guidelines.push({
          type: 'heading',
          anchor: text,
          message: 'Commencez la section par un résumé bref et concis.'
        });
      });

      doc.querySelectorAll('ul, ol').forEach((list) => {
        const label = list.tagName === 'UL' ? 'Liste à puces' : 'Liste numérotée';
        guidelines.push({
          type: 'list-transition',
          anchor: label,
          message: 'Reliez la liste par une transition claire entre les étapes.'
        });
        const previous = list.previousElementSibling;
        const hasIntro = previous && previous.textContent.trim().length > 0 && previous.textContent.trim().endsWith(':');
        if (!hasIntro) {
          guidelines.push({
            type: 'list-intro',
            anchor: label,
            message: 'Ajoutez une phrase introductive se terminant par un deux-points avant la liste.'
          });
        }
      });

      const textContent = doc.body.textContent || '';
      const pronounMatches = Array.from(
        new Set(textContent.match(/\b(?:il|elle|ils|elles|lui|leur|leurs|son|sa|ses|eux)\b/gi) || [])
      );
      pronounMatches.forEach((item) => {
        guidelines.push({
          type: 'pronoun',
          anchor: item,
          message: 'Précisez le référent du pronom pour éviter toute ambiguïté.'
        });
      });

      const acronymMatches = Array.from(new Set(textContent.match(/\b[A-Z]{2,}\b/g))) || [];
      acronymMatches.forEach((acronym) => {
        if (!acronymDB[acronym]) {
          guidelines.push({
            type: 'acronym',
            anchor: acronym,
            message: "Documentez l'acronyme ou ajoutez-le à la base des acronymes."
          });
        }
      });

      return guidelines;
    }

    function detectBlockingIssues(html, qaItems) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<div>${html}</div>`, 'text/html');
      const textContent = doc.body.textContent || '';
      const qaText = qaItems.map((item) => `${item.question} ${item.answer}`).join(' ');

      const emojiRegex = /[\u{1F300}-\u{1FAFF}\u{1F600}-\u{1F64F}\u{1F900}-\u{1F9FF}]/u;
      const warnings = [];

      if (emojiRegex.test(textContent) || emojiRegex.test(qaText)) {
        warnings.push('Retirez les émojis pour respecter la charte éditoriale.');
      }

      if (doc.querySelector('img')) {
        warnings.push('Les images ne sont pas autorisées dans la procédure.');
      }

      if (doc.querySelector('a[href]')) {
        warnings.push('Les liens URL doivent être retirés avant export.');
      }

      if (doc.querySelector('table')) {
        warnings.push('Les tableaux ne peuvent pas être exportés dans ce format.');
      }

      const rawText = sanitizeHTML(html).replace(/<[^>]+>/g, '\n');
      const hasUnformattedList = /^\s*[-*]\s+.+/m.test(rawText);
      if (hasUnformattedList) {
        warnings.push('Convertissez toutes les listes en listes formatées via la barre d’édition.');
      }

      return warnings;
    }

    function parseKeywords(value = '') {
      return value
        .split(',')
        .map((item) => item.trim())
        .filter(Boolean);
    }

    function buildMarkdown(metadata, contentHTML, qaItems) {
      const td = new TurndownService({ headingStyle: 'atx' });
      td.addRule('removeStyles', {
        filter: ['span'],
        replacement: (content) => content
      });

      const contentMarkdown = td.turndown(contentHTML || '');
      const cleanContent = contentMarkdown
        .replace(/[ \t]+/g, ' ')
        .replace(/\s+\n/g, '\n')
        .replace(/\n{3,}/g, '\n\n')
        .trim();

      const lines = [
        '---',
        `Titre: ${metadata.title}`,
        `Référence: ${metadata.reference}`,
        `Auteur: ${metadata.author}`,
        `Périmètre métier: ${metadata.businessScope}`,
        `Périmètre société: ${metadata.companyScope}`,
        `Périmètre géographique: ${metadata.geoScope}`,
        `Mots clefs: ${metadata.keywords}`,
        `Résumé: ${metadata.summary}`,
        `Procédure mère: ${metadata.parentProcedure}`,
        `Historique des modifications: ${metadata.changeHistory}`,
        `Date d'entrée en vigueur: ${metadata.effectiveDate}`,
        '---',
        '',
        cleanContent
      ];

      if (qaItems.length > 0) {
        lines.push('', '## Questions & Réponses');
        qaItems.forEach((item, index) => {
          const question = item.question.trim().replace(/[ \t]+/g, ' ');
          const answer = item.answer.trim().replace(/[ \t]+/g, ' ');
          lines.push('', `### Question ${index + 1}`, `**Question :** ${question}`, `**Réponse :** ${answer}`);
        });
      }

      return lines.join('\n').replace(/\n{3,}/g, '\n\n').trim();
    }

    const FRONTMATTER_KEY_MAP = {
      Titre: 'title',
      'Référence': 'reference',
      Auteur: 'author',
      'Périmètre métier': 'businessScope',
      'Périmètre société': 'companyScope',
      'Périmètre géographique': 'geoScope',
      'Mots clefs': 'keywords',
      'Résumé': 'summary',
      'Procédure mère': 'parentProcedure',
      'Historique des modifications': 'changeHistory',
      "Date d'entrée en vigueur": 'effectiveDate'
    };

    function parseMarkdownProcedure(markdown) {
      const normalizedMetadata = { ...initialMetadata };
      if (typeof markdown !== 'string') {
        return {
          metadata: normalizedMetadata,
          contentHTML: INITIAL_CONTENT_HTML,
          qaItems: createInitialQAItems()
        };
      }

      if (typeof marked === 'undefined' || typeof marked.parse !== 'function') {
        throw new Error('Le moteur de conversion Markdown est indisponible.');
      }

      let body = markdown;
      const frontMatterMatch = markdown.match(/^---\s*([\s\S]*?)\s*---\s*/);

      if (frontMatterMatch) {
        const frontMatterContent = frontMatterMatch[1];
        body = markdown.slice(frontMatterMatch[0].length);

        frontMatterContent.split(/\r?\n/).forEach((line) => {
          if (!line.includes(':')) {
            return;
          }

          const [rawKey, ...rawValueParts] = line.split(':');
          if (!rawKey || rawValueParts.length === 0) {
            return;
          }

          const key = rawKey.trim();
          const value = rawValueParts.join(':').trim();
          const metadataKey = FRONTMATTER_KEY_MAP[key];

          if (metadataKey) {
            normalizedMetadata[metadataKey] = value;
          }
        });
      }

      let qaMarkdown = '';
      const qaHeadingRegex = /##\s+Questions\s*&\s*Réponses/i;
      const qaIndex = body.search(qaHeadingRegex);

      if (qaIndex !== -1) {
        qaMarkdown = body.slice(qaIndex);
        body = body.slice(0, qaIndex);
      }

      const qaItems = [];
      if (qaMarkdown) {
        const qaItemRegex = /###\s+Question\s+\d+\s*[\r\n]+(?:\*\*Question\s*:\*\*\s*)([\s\S]*?)(?:\r?\n)+(?:\*\*Réponse\s*:\*\*\s*)([\s\S]*?)(?=(?:\r?\n###\s+Question|\r?\n##\s+|$))/gi;
        let match;

        while ((match = qaItemRegex.exec(qaMarkdown)) !== null) {
          const question = (match[1] || '').replace(/\r\n/g, '\n').trim();
          const answer = (match[2] || '').replace(/\r\n/g, '\n').trim();
          qaItems.push({ question, answer });
        }
      }

      const contentMarkdown = body.trim();
      let htmlContent = contentMarkdown ? marked.parse(contentMarkdown) : '';
      if (typeof htmlContent !== 'string' || htmlContent.trim().length === 0) {
        htmlContent = '<p></p>';
      }

      const sanitizedHTML = sanitizeHTML(htmlContent);
      const normalizedQAItems = qaItems.length > 0 ? qaItems : createInitialQAItems();

      return {
        metadata: normalizedMetadata,
        contentHTML: sanitizedHTML,
        qaItems: normalizedQAItems
      };
    }

    let logoAssetCache = null;
    let logoAssetPromise = null;

    async function loadLogoAsset() {
      if (logoAssetCache) {
        return logoAssetCache;
      }

      if (logoAssetPromise) {
        return logoAssetPromise;
      }

      logoAssetPromise = (async () => {
        try {
          const response = await fetch(LFB_LOGO_URL, { mode: 'cors' });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const blob = await response.blob();
          const dataUrl = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = () => reject(new Error('Lecture du logo impossible'));
            reader.readAsDataURL(blob);
          });

          const dimensions = await new Promise((resolve, reject) => {
            const image = new Image();
            image.onload = () => resolve({ width: image.width, height: image.height });
            image.onerror = () => reject(new Error('Chargement du logo impossible'));
            image.src = dataUrl;
          });

          const asset = {
            dataUrl,
            width: dimensions.width,
            height: dimensions.height
          };

          logoAssetCache = asset;
          return asset;
        } catch (error) {
          console.error('Impossible de charger le logo LFB :', error);
          return null;
        } finally {
          logoAssetPromise = null;
        }
      })();

      return logoAssetPromise;
    }

    async function exportToPDF(markdown, metadata) {
      try {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit: 'pt', format: 'a4' });
        const margin = 48;
        const pageWidth = pdf.internal.pageSize.getWidth();
        const usableWidth = pageWidth - margin * 2;
        const lineHeight = 18;
        const footerPadding = 72;
        const logoAsset = await loadLogoAsset();
        let headerHeight = 0;

        const drawHeader = () => {
          if (!logoAsset || !logoAsset.width || !logoAsset.height) {
            headerHeight = 0;
            return headerHeight;
          }

          const maxLogoWidth = Math.min(logoAsset.width, pageWidth - margin * 2, 200);
          if (maxLogoWidth <= 0) {
            headerHeight = 0;
            return headerHeight;
          }

          const displayHeight = (logoAsset.height / logoAsset.width) * maxLogoWidth;
          const verticalOffset = 16;
          const yPosition = Math.max(24, margin - verticalOffset);
          pdf.addImage(logoAsset.dataUrl, 'JPEG', margin, yPosition, maxLogoWidth, displayHeight);
          headerHeight = displayHeight + (margin - yPosition) + 8;
          return headerHeight;
        };

        if (logoAsset) {
          drawHeader();
        }

        let cursorY = margin + headerHeight;

        const addTextBlock = (text, options = {}) => {
          const paragraphs = text.split('\n');
          pdf.setFont('Helvetica', options.bold ? 'bold' : 'normal');
          pdf.setFontSize(options.size || 12);
          paragraphs.forEach((paragraph) => {
            const lines = pdf.splitTextToSize(paragraph, usableWidth);
            lines.forEach((line) => {
              if (cursorY + lineHeight > pdf.internal.pageSize.getHeight() - footerPadding) {
                pdf.addPage();
                if (logoAsset) {
                  drawHeader();
                } else {
                  headerHeight = 0;
                }
                cursorY = margin + headerHeight;
              }
              pdf.text(line, margin, cursorY);
              cursorY += lineHeight;
            });
            cursorY += lineHeight * 0.5;
          });
        };

        const [metaBlock, bodyBlock] = markdown.split('\n---\n');
        const bodyText = bodyBlock ? bodyBlock.replace(/^\s+/, '') : markdown;
        addTextBlock('Procédure', { size: 18, bold: true });
        addTextBlock(metaBlock.replace(/---\n?/, ''), { size: 11 });
        addTextBlock(bodyText, { size: 12 });

        const totalPages = pdf.getNumberOfPages();
        for (let i = 1; i <= totalPages; i += 1) {
          pdf.setPage(i);
          const footerY = pdf.internal.pageSize.getHeight() - 40;
          const pageLabel = `${i} / ${totalPages}`;
          pdf.setFont('Helvetica', 'normal');
          pdf.setFontSize(10);
          pdf.text(`${metadata.reference || 'Réf. non renseignée'} | ${metadata.title || 'Titre non renseigné'} | ${metadata.effectiveDate || 'Date non renseignée'}`, margin, footerY);
          pdf.text(pageLabel, pageWidth - margin, footerY, { align: 'right' });
        }

        pdf.save(`${metadata.reference || 'procedure'}.pdf`);
      } catch (error) {
        console.error('Erreur lors de la génération du PDF :', error);
        throw error;
      }
    }

    function App() {
      const [metadata, setMetadata] = useState(() => ({ ...initialMetadata }));
      const [contentHTML, setContentHTML] = useState(INITIAL_CONTENT_HTML);
      const [qaItems, setQaItems] = useState(createInitialQAItems);
      const [guidelines, setGuidelines] = useState([]);
      const [blockingWarnings, setBlockingWarnings] = useState([]);
      const [preview, setPreview] = useState({ open: false, markdown: '' });
      const [hasStarted, setHasStarted] = useState(false);
      const [glossary, setGlossary] = useState({});
      const [isGlossaryLoading, setIsGlossaryLoading] = useState(true);
      const [glossaryError, setGlossaryError] = useState(null);
      const [selectOptions, setSelectOptions] = useState(loadInitialSelectOptions);
      const [selectOptionDrafts, setSelectOptionDrafts] = useState(createEmptyOptionDrafts);
      const editorRef = useRef(null);
      const fileInputRef = useRef(null);
      const [isExportingPDF, setIsExportingPDF] = useState(false);
      const keywordList = useMemo(() => parseKeywords(metadata.keywords), [metadata.keywords]);
      const [keywordInput, setKeywordInput] = useState('');

      const isFormDirty = useMemo(() => {
        const metadataFilled = Object.values(metadata).some((value) => `${value || ''}`.trim().length > 0);
        const isDefaultContent = contentHTML.trim() === INITIAL_CONTENT_HTML.trim();
        const contentFilled = !isDefaultContent && contentHTML
          .replace(/<[^>]+>/g, ' ')
          .replace(/&nbsp;/g, ' ')
          .trim().length > 0;
        const qaFilled = qaItems.some(
          (item) => item.question.trim().length > 0 || item.answer.trim().length > 0
        );
        return metadataFilled || contentFilled || qaFilled;
      }, [metadata, contentHTML, qaItems]);

      useEffect(() => {
        if (editorRef.current) {
          editorRef.current.innerHTML = INITIAL_CONTENT_HTML;
        }
      }, []);

      useEffect(() => {
        if (typeof window === 'undefined' || !window.localStorage) {
          return;
        }

        try {
          window.localStorage.setItem(SELECT_OPTION_STORAGE_KEY, JSON.stringify(selectOptions));
        } catch (error) {
          console.warn('Impossible de sauvegarder les options personnalisées :', error);
        }
      }, [selectOptions]);

      useEffect(() => {
        let hasClearedValue = false;
        setMetadata((prev) => {
          let next = prev;
          SELECT_FIELD_KEYS.forEach((key) => {
            const allowed = selectOptions[key] || [];
            if (prev[key] && !allowed.includes(prev[key])) {
              if (next === prev) {
                next = { ...prev };
              }
              next[key] = '';
              hasClearedValue = true;
            }
          });
          return next;
        });

        if (hasClearedValue) {
          setHasStarted(true);
        }
      }, [selectOptions]);

      const handleMetadataChange = (key, value) => {
        setMetadata((prev) => ({ ...prev, [key]: value }));
        setHasStarted(true);
      };

      const handleSelectOptionDraftChange = (fieldKey, value) => {
        setSelectOptionDrafts((prev) => ({ ...prev, [fieldKey]: value }));
      };

      const handleAddSelectOption = (fieldKey) => {
        const draft = (selectOptionDrafts[fieldKey] || '').trim();
        if (!draft) {
          setSelectOptionDrafts((prev) => ({ ...prev, [fieldKey]: '' }));
          return;
        }

        let hasAdded = false;
        setSelectOptions((prev) => {
          const existing = prev[fieldKey] || [];
          if (existing.some((option) => option.toLowerCase() === draft.toLowerCase())) {
            return prev;
          }

          hasAdded = true;
          return {
            ...prev,
            [fieldKey]: [...existing, draft]
          };
        });

        if (hasAdded) {
          setSelectOptionDrafts((prev) => ({ ...prev, [fieldKey]: '' }));
          setHasStarted(true);
        }
      };

      const handleRemoveSelectOption = (fieldKey, option) => {
        let hasRemoved = false;
        setSelectOptions((prev) => {
          const existing = prev[fieldKey] || [];
          const filtered = existing.filter((value) => value !== option);
          if (filtered.length === existing.length) {
            return prev;
          }

          hasRemoved = true;
          return {
            ...prev,
            [fieldKey]: filtered
          };
        });

        if (!hasRemoved) {
          return;
        }

        setMetadata((prev) => {
          if (prev[fieldKey] !== option) {
            return prev;
          }
          return { ...prev, [fieldKey]: '' };
        });

        setHasStarted(true);
      };

      const handleResetSelectOptions = (fieldKey) => {
        const defaults = DEFAULT_SELECT_OPTIONS[fieldKey] || [];
        let hasChanged = false;

        setSelectOptions((prev) => {
          const existing = prev[fieldKey] || [];
          if (existing.length === defaults.length && existing.every((value, index) => value === defaults[index])) {
            return prev;
          }

          hasChanged = true;
          return {
            ...prev,
            [fieldKey]: [...defaults]
          };
        });

        setSelectOptionDrafts((prev) => ({ ...prev, [fieldKey]: '' }));

        setMetadata((prev) => {
          if (prev[fieldKey] === '' || defaults.includes(prev[fieldKey])) {
            return prev;
          }

          hasChanged = true;
          return { ...prev, [fieldKey]: '' };
        });

        if (hasChanged) {
          setHasStarted(true);
        }
      };

      const handleKeywordAdd = (value) => {
        const trimmed = value.trim();
        if (!trimmed) {
          setKeywordInput('');
          return;
        }

        const existingKeywords = parseKeywords(metadata.keywords);
        if (existingKeywords.includes(trimmed)) {
          setKeywordInput('');
          return;
        }

        const updated = [...existingKeywords, trimmed];
        setMetadata((prev) => ({ ...prev, keywords: updated.join(', ') }));
        setKeywordInput('');
        setHasStarted(true);
      };

      const handleKeywordRemove = (indexToRemove) => {
        const updated = keywordList.filter((_, index) => index !== indexToRemove);
        setMetadata((prev) => ({ ...prev, keywords: updated.join(', ') }));
        setHasStarted(true);
      };

      const handleKeywordInputChange = (event) => {
        setKeywordInput(event.target.value);
      };

      const handleKeywordKeyDown = (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          handleKeywordAdd(keywordInput);
        } else if (event.key === 'Backspace' && keywordInput === '') {
          if (keywordList.length === 0) {
            return;
          }
          event.preventDefault();
          handleKeywordRemove(keywordList.length - 1);
        }
      };

      const handleImportClick = () => {
        if (fileInputRef.current) {
          fileInputRef.current.value = '';
          fileInputRef.current.click();
        }
      };

      const handleImportMarkdown = async (event) => {
        const input = event.target;
        const file = input && input.files ? input.files[0] : null;

        if (!file) {
          return;
        }

        try {
          const text = await file.text();
          const { metadata: importedMetadata, contentHTML: importedContentHTML, qaItems: importedQAItems } = parseMarkdownProcedure(text);
          const nextGuidelines = computeGuidelines(importedContentHTML, glossary);
          const nextBlockingWarnings = detectBlockingIssues(importedContentHTML, importedQAItems);

          setMetadata(importedMetadata);
          setContentHTML(importedContentHTML);
          setQaItems(importedQAItems);
          setGuidelines(nextGuidelines);
          setBlockingWarnings(nextBlockingWarnings);
          setPreview({ open: false, markdown: '' });
          setHasStarted(true);
          setKeywordInput('');

          if (editorRef.current) {
            editorRef.current.innerHTML = importedContentHTML;
          }
        } catch (error) {
          console.error("Erreur lors de l'import Markdown :", error);
          window.alert("Le fichier Markdown n'a pas pu être importé. Vérifiez son format et réessayez.");
        } finally {
          if (input) {
            input.value = '';
          }
        }
      };

      const updateContent = (html) => {
        const sanitized = sanitizeHTML(html);
        setContentHTML(sanitized);
        setGuidelines(computeGuidelines(sanitized, glossary));
        setBlockingWarnings(detectBlockingIssues(sanitized, qaItems));
      };

      const handleEditorInput = (event) => {
        setHasStarted(true);
        updateContent(event.currentTarget.innerHTML);
      };

      const insertRationalBlock = () => {
        if (!editorRef.current) {
          return;
        }

        editorRef.current.focus();

        const rationalHTML = `
<section class="rational-block" data-block-type="rationnel">
  <div class="rational-block-title">Rationnel</div>
  <p>Expliquez ici le rationnel associé à cette section.</p>
</section><p></p>`;

        document.execCommand('insertHTML', false, rationalHTML);
        setHasStarted(true);
        updateContent(editorRef.current.innerHTML);

        requestAnimationFrame(() => {
          if (!editorRef.current) {
            return;
          }

          const selection = window.getSelection();
          const blocks = editorRef.current.querySelectorAll('.rational-block[data-block-type="rationnel"]');
          if (!selection || blocks.length === 0) {
            return;
          }

          const lastBlock = blocks[blocks.length - 1];
          const paragraph = lastBlock.querySelector('p');
          if (!paragraph) {
            return;
          }

          const range = document.createRange();
          range.selectNodeContents(paragraph);
          range.collapse(true);
          selection.removeAllRanges();
          selection.addRange(range);
        });
      };

      const handleQAChange = (index, field, value) => {
        setQaItems((prev) => {
          const next = [...prev];
          next[index] = { ...next[index], [field]: value };
          return next;
        });
        setHasStarted(true);
      };

      const addQAItem = () => {
        setQaItems((prev) => [...prev, { question: '', answer: '' }]);
        setHasStarted(true);
      };

      const removeQAItem = (index) => {
        setQaItems((prev) => prev.filter((_, i) => i !== index));
      };

      useEffect(() => {
        setGuidelines(computeGuidelines(contentHTML, glossary));
        setBlockingWarnings(detectBlockingIssues(contentHTML, qaItems));
      }, [qaItems, contentHTML, glossary]);

      useEffect(() => {
        let isCancelled = false;

        const normalizeGlossary = (data) => {
          if (!data) {
            return {};
          }

          if (Array.isArray(data)) {
            return data.reduce((acc, entry) => {
              if (entry && typeof entry.term === 'string' && typeof entry.definition === 'string') {
                acc[entry.term] = entry.definition;
              }
              return acc;
            }, {});
          }

          if (data && typeof data === 'object' && Array.isArray(data.acronyms)) {
            return data.acronyms.reduce((acc, entry) => {
              if (entry && typeof entry.term === 'string' && typeof entry.definition === 'string') {
                acc[entry.term] = entry.definition;
              }
              return acc;
            }, {});
          }

          if (data && typeof data === 'object') {
            return Object.entries(data).reduce((acc, [key, value]) => {
              if (typeof key === 'string' && typeof value === 'string') {
                acc[key] = value;
              }
              return acc;
            }, {});
          }

          return {};
        };

        async function loadGlossary() {
          try {
            const response = await fetch('./glossary.json');
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();
            if (isCancelled) {
              return;
            }

            setGlossary(normalizeGlossary(data));
            setGlossaryError(null);
          } catch (error) {
            if (isCancelled) {
              return;
            }

            console.error('Erreur lors du chargement du glossaire :', error);
            setGlossaryError("Le glossaire n'a pas pu être chargé.");
            setGlossary({});
          } finally {
            if (!isCancelled) {
              setIsGlossaryLoading(false);
            }
          }
        }

        loadGlossary();

        return () => {
          isCancelled = true;
        };
      }, []);

      const markdownPreview = useMemo(() => buildMarkdown(metadata, contentHTML, qaItems), [metadata, contentHTML, qaItems]);

      const handleNewProcedure = () => {
        if (isFormDirty) {
          const confirmReset = window.confirm(
            'Voulez-vous vraiment démarrer une nouvelle procédure ? Les informations en cours seront effacées.'
          );
          if (!confirmReset) {
            return;
          }
        }

        const initialQAItems = createInitialQAItems();

        setMetadata(() => ({ ...initialMetadata }));
        setQaItems(initialQAItems);
        setContentHTML(INITIAL_CONTENT_HTML);
        setGuidelines(computeGuidelines(INITIAL_CONTENT_HTML, glossary));
        setBlockingWarnings(detectBlockingIssues(INITIAL_CONTENT_HTML, initialQAItems));
        setPreview({ open: false, markdown: '' });
        setHasStarted(true);
        setKeywordInput('');

        if (editorRef.current) {
          editorRef.current.innerHTML = INITIAL_CONTENT_HTML;
        }

        const firstMetadataField = document.getElementById(metadataFields[0].key);
        if (firstMetadataField) {
          firstMetadataField.focus();
        }
      };

      const handlePreview = () => {
        setPreview({ open: true, markdown: markdownPreview });
      };

      const handleExportMarkdown = () => {
        const markdown = markdownPreview;
        const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `${metadata.reference || 'procedure'}.md`;
        link.click();
        URL.revokeObjectURL(link.href);
      };

      const handleExportPDF = async () => {
        try {
          setIsExportingPDF(true);
          await exportToPDF(markdownPreview, metadata);
        } catch (error) {
          window.alert("Le PDF n'a pas pu être généré. Veuillez réessayer.");
        } finally {
          setIsExportingPDF(false);
        }
      };

      return (
        <React.Fragment>
          <header>
            <div className="header-brand">
              <img src={LFB_LOGO_URL} alt="Logo LFB" className="header-logo" />
              <h1>Studio de Procédures IA Friendly</h1>
            </div>
            <div className="header-actions">
              <input
                type="file"
                accept=".md,.markdown,text/markdown"
                ref={fileInputRef}
                style={{ display: 'none' }}
                onChange={handleImportMarkdown}
              />
              <button type="button" className="secondary-btn" onClick={handleImportClick}>
                Importer un Markdown
              </button>
              <button type="button" className="new-procedure-btn" onClick={handleNewProcedure}>
                Nouvelle procédure
              </button>
            </div>
          </header>
          <div className="layout">
            <div className="content">
              {!hasStarted && (
                <section className="card info-card">
                  <h2>Démarrer une nouvelle procédure</h2>
                  <p>
                    Pour créer un nouveau document, cliquez sur le bouton « Nouvelle procédure » situé dans l'entête.
                    Un canevas vierge sera automatiquement préparé pour vous permettre de renseigner chaque section.
                  </p>
                  <ul>
                    <li>Complétez les métadonnées pour contextualiser la procédure.</li>
                    <li>Rédigez le contenu opérationnel à l'aide de l'éditeur enrichi.</li>
                    <li>Finalisez par la session de Questions &amp; Réponses avant l'export.</li>
                  </ul>
                </section>
              )}
              <section className="card">
                <h2>1. Métadonnées</h2>
                <div className="metadata-grid">
                  {metadataGroups.map((group) => (
                    <section className="metadata-group" key={group.key}>
                      <div className="metadata-group-header">
                        <h3>{group.title}</h3>
                        {group.description && <p>{group.description}</p>}
                      </div>
                      <div className="metadata-group-fields">
                        {group.fields.map((field) => (
                          <div key={field.key}>
                            <label htmlFor={field.key}>{field.label}</label>
                            {field.type === 'select' ? (
                              <>
                                <select
                                  id={field.key}
                                  value={metadata[field.key]}
                                  onChange={(event) => handleMetadataChange(field.key, event.target.value)}
                                >
                                  <option value="">Sélectionnez une option</option>
                                  {(selectOptions[field.key] || field.options || []).map((option) => (
                                    <option value={option} key={option}>
                                      {option}
                                    </option>
                                  ))}
                                </select>
                                {field.hint && <p className="field-hint">{field.hint}</p>}
                              </>
                            ) : field.key === 'keywords' ? (
                              <div className="keyword-input-wrapper">
                                <input
                                  id={field.key}
                                  type="text"
                                  value={keywordInput}
                                  placeholder={field.placeholder}
                                  onChange={handleKeywordInputChange}
                                  onKeyDown={handleKeywordKeyDown}
                                />
                                <div className="keyword-tags" aria-live="polite">
                                  {keywordList.map((keyword, index) => {
                                    const palette = KEYWORD_COLOR_PALETTE[index % KEYWORD_COLOR_PALETTE.length];
                                    return (
                                      <span
                                        key={`${keyword}-${index}`}
                                        className="keyword-tag"
                                        style={{
                                          background: palette.background,
                                          color: palette.color,
                                          borderColor: palette.border
                                        }}
                                      >
                                        <span>{keyword}</span>
                                        <button
                                          type="button"
                                          className="keyword-remove"
                                          onClick={() => handleKeywordRemove(index)}
                                          aria-label={`Retirer le mot clef ${keyword}`}
                                        >
                                          ×
                                        </button>
                                      </span>
                                    );
                                  })}
                                  {keywordList.length === 0 && (
                                    <span className="keyword-empty">Ajoutez un mot clef puis validez avec Entrée.</span>
                                  )}
                                </div>
                                {field.hint && <p className="field-hint">{field.hint}</p>}
                              </div>
                            ) : field.type === 'textarea' ? (
                              <>
                                <textarea
                                  id={field.key}
                                  value={metadata[field.key]}
                                  placeholder={field.placeholder}
                                  onChange={(event) => handleMetadataChange(field.key, event.target.value)}
                                />
                                {field.hint && <p className="field-hint">{field.hint}</p>}
                              </>
                            ) : (
                              <>
                                <input
                                  id={field.key}
                                  type={field.type}
                                  value={metadata[field.key]}
                                  placeholder={field.placeholder}
                                  onChange={(event) => handleMetadataChange(field.key, event.target.value)}
                                />
                                {field.hint && <p className="field-hint">{field.hint}</p>}
                              </>
                            )}
                          </div>
                        ))}
                      </div>
                    </section>
                  ))}
                </div>
              </section>

              <section className="card backoffice-card">
                <h2>Backoffice — Options des champs</h2>
                <p className="backoffice-description">
                  Personnalisez les listes de choix proposées dans les menus déroulants du formulaire.
                </p>
                {selectFieldDefinitions.map((field) => {
                  const options = selectOptions[field.key] || [];
                  return (
                    <div className="backoffice-section" key={field.key}>
                      <div className="backoffice-section-header">
                        <h3>{field.label}</h3>
                        <button
                          type="button"
                          className="backoffice-reset-btn"
                          onClick={() => handleResetSelectOptions(field.key)}
                        >
                          Réinitialiser
                        </button>
                      </div>
                      <label htmlFor={`${field.key}-new-option`}>Ajouter une option</label>
                      <div className="backoffice-controls">
                        <input
                          id={`${field.key}-new-option`}
                          type="text"
                          value={selectOptionDrafts[field.key] || ''}
                          placeholder="Nouvelle option"
                          onChange={(event) => handleSelectOptionDraftChange(field.key, event.target.value)}
                          onKeyDown={(event) => {
                            if (event.key === 'Enter') {
                              event.preventDefault();
                              handleAddSelectOption(field.key);
                            }
                          }}
                        />
                        <button type="button" className="backoffice-add-btn" onClick={() => handleAddSelectOption(field.key)}>
                          Ajouter
                        </button>
                      </div>
                      <div className="option-list" aria-live="polite">
                        {options.length === 0 ? (
                          <span className="option-empty">Aucune option enregistrée pour le moment.</span>
                        ) : (
                          options.map((option) => (
                            <span className="option-pill" key={option}>
                              <span>{option}</span>
                              <button
                                type="button"
                                className="option-pill-remove"
                                aria-label={`Supprimer l'option ${option}`}
                                onClick={() => handleRemoveSelectOption(field.key, option)}
                              >
                                ×
                              </button>
                            </span>
                          ))
                        )}
                      </div>
                    </div>
                  );
                })}
              </section>

              <section className="card editor-card">
                <h2>2. Contenu de la procédure</h2>
                <div className="toolbar">
                  <button type="button" onClick={() => formatSelection('formatBlock', 'H1')}>H1</button>
                  <button type="button" onClick={() => formatSelection('formatBlock', 'H2')}>H2</button>
                  <button type="button" onClick={() => formatSelection('formatBlock', 'H3')}>H3</button>
                  <button type="button" onClick={() => formatSelection('formatBlock', 'H4')}>H4</button>
                  <button type="button" onClick={() => formatSelection('bold')}>Gras</button>
                  <button type="button" onClick={() => formatSelection('italic')}>Italique</button>
                  <button type="button" onClick={insertRationalBlock}>Rationnel</button>
                  <button type="button" onClick={() => formatSelection('insertUnorderedList')}>Liste à puces</button>
                  <button type="button" onClick={() => formatSelection('insertOrderedList')}>Liste numérotée</button>
                </div>
                <div
                  className="editor"
                  contentEditable
                  ref={editorRef}
                  onInput={handleEditorInput}
                  suppressContentEditableWarning
                  spellCheck
                  aria-label="Zone d'édition du contenu"
                />
              </section>

              <section className="card">
                <h2>3. Questions & Réponses</h2>
                <p style={{ color: 'var(--muted)', fontSize: '14px', marginTop: 0 }}>
                  Structurez la session de questions-réponses qui conclura la procédure.
                </p>
                <div className="qa-list" style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
                  {qaItems.map((item, index) => (
                    <div className="qa-item" key={index}>
                      <div>
                        <label htmlFor={`question-${index}`}>Question</label>
                        <textarea
                          id={`question-${index}`}
                          value={item.question}
                          placeholder="Formulez la question de manière explicite"
                          onChange={(event) => handleQAChange(index, 'question', event.target.value)}
                        />
                      </div>
                      <div>
                        <label htmlFor={`answer-${index}`}>Réponse</label>
                        <textarea
                          id={`answer-${index}`}
                          value={item.answer}
                          placeholder="Fournissez une réponse précise et contextualisée"
                          onChange={(event) => handleQAChange(index, 'answer', event.target.value)}
                        />
                      </div>
                      <div className="qa-actions">
                        {qaItems.length > 1 && (
                          <button type="button" className="remove-btn" onClick={() => removeQAItem(index)}>
                            Retirer
                          </button>
                        )}
                      </div>
                    </div>
                  ))}
                </div>
                <div className="export-actions" style={{ justifyContent: 'flex-start', marginTop: '16px' }}>
                  <button type="button" className="secondary-btn" onClick={addQAItem}>
                    Ajouter une question
                  </button>
                </div>
              </section>

              <section className="card">
                <h2>Aperçu & Export</h2>
                {blockingWarnings.length > 0 && (
                  <div className="warning">
                    ⚠️ Export impossible tant que les points suivants ne sont pas corrigés :
                    <ul className="insight-list">
                      {blockingWarnings.map((warning, index) => (
                        <li key={index}>{warning}</li>
                      ))}
                    </ul>
                  </div>
                )}
                <div className="export-actions">
                  <button type="button" className="secondary-btn" onClick={handlePreview}>
                    Prévisualiser le Markdown
                  </button>
                  <button
                    type="button"
                    className="primary-btn"
                    onClick={handleExportMarkdown}
                    disabled={blockingWarnings.length > 0}
                  >
                    Exporter en Markdown
                  </button>
                  <button
                    type="button"
                    className="primary-btn"
                    onClick={handleExportPDF}
                    disabled={blockingWarnings.length > 0 || isExportingPDF}
                  >
                    {isExportingPDF ? 'Export PDF en cours…' : 'Exporter en PDF'}
                  </button>
                </div>
              </section>
            </div>

            <aside className="insights">
              <div className="insight-card">
                <h3>Guidelines IA Friendly</h3>
                {guidelines.length === 0 ? (
                  <p style={{ color: 'var(--muted)', margin: 0 }}>Commencez votre rédaction pour recevoir des recommandations.</p>
                ) : (
                  <ul className="insight-list guideline-comment-list">
                    {guidelines.map((item, index) => (
                      <li key={`${item.type}-${item.anchor || index}`}>
                        <div className="insight-comment">
                          <span className="comment-anchor">{item.anchor || 'Texte'}</span>
                          <span className="comment-message">{item.message}</span>
                        </div>
                      </li>
                    ))}
                  </ul>
                )}
              </div>
              <div className="insight-card">
                <h3>Base des acronymes</h3>
                {isGlossaryLoading ? (
                  <p style={{ color: 'var(--muted)', margin: 0 }}>Chargement du glossaire…</p>
                ) : glossaryError ? (
                  <p style={{ color: 'var(--warning)', margin: 0 }}>{glossaryError}</p>
                ) : Object.keys(glossary).length === 0 ? (
                  <p style={{ color: 'var(--muted)', margin: 0 }}>Aucun acronyme disponible pour le moment.</p>
                ) : (
                  <ul className="insight-list">
                    {Object.entries(glossary).map(([acronym, definition]) => (
                      <li key={acronym}>
                        <strong>{acronym}</strong> : {definition}
                      </li>
                    ))}
                  </ul>
                )}
              </div>
            </aside>
          </div>

          {preview.open && (
            <div className="preview-modal" role="dialog" aria-modal="true">
              <div className="preview-content">
                <div className="preview-header">
                  <h3 style={{ margin: 0 }}>Aperçu Markdown</h3>
                  <button type="button" className="secondary-btn" onClick={() => setPreview({ open: false, markdown: '' })}>
                    Fermer
                  </button>
                </div>
                <div className="preview-body">
                  <pre>{preview.markdown}</pre>
                </div>
              </div>
            </div>
          )}
        </React.Fragment>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
